---
layout: post
title: "[AI 개발] 주말 프로젝트: 광고 없는 Google Drive 동기화 앱"
date: 2026-01-25 20:00:00 +0900
categories: android-development
tags:
- android
- google-drive
- sync
- ai
- kotlin
---

* 목차
{:toc}

---

주말 동안 간단한 안드로이드 앱 하나를 만들었다.
로고는 Nanobana로 만들었다. 

<img src="/assets/images/20260125_drivesync.png" alt="drivesync Logo" width="60%" style="border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">

토요일과 일요일, 이틀 정도 집중해서 만든 앱인데 목적은 아주 단순했다.

**광고 없는 Google Drive 동기화**

# 왜 만들었나

나는 평소 노트 정리 도구로 Obsidian을 사용한다.
노트 저장소는 Google Drive와 동기화해서 관리하고 있고, 그동안은 **Autosync for Google Drive**를 써왔다.

이 앱은 기능적으로는 꽤 안정적이지만,

- 광고가 점점 잦아지고,
- 커스터마이징 옵션이 제한적이라,
- "조금 더 내가 원하는 대로" 조정하기 어려웠다.

그래서 어느 순간 이런 생각이 들었다.

> "이거, 그냥 내가 하나 만들면 되지 않나?"

# 목표는 '완벽한 앱'이 아니라 '내가 쓸 수 있는 앱'

처음부터 모든 기능을 다 넣을 생각은 없었다.
실제로 필요한 기능을 정리해보니 아래 정도였다.

1. Google Drive 동기화
2. 여러 계정 동기화
3. 동기화 주기 설정
4. Wi-Fi 환경에서만 동기화
5. 충전 중일 때만 동기화
6. 동기화 완료 알림
7. 충돌 해결 전략

하지만 현실적으로 핵심은 앞의 1, 2, 3번이었다.
그래서 이번 주말 목표는 명확하게 정했다.

**"1, 2, 3번 기능만 구현한다."**

# AI를 곁들인 개발 과정

이번 프로젝트의 또 다른 특징은 **AI를 적극적으로 활용했다**는 점이다.
두 모델을 병행하면서 역할을 분리해 사용했다.

- **Claude** → 구조 설계, 코드 리팩토링, 로직 검증
- **Gemini** → Android API 힌트, Google Drive 연동 샘플, Coroutine/WorkManager 레퍼런스

AI를 "코드를 대신 작성해주는 도구"로 쓰기보단,
**설계 검증과 시행착오를 줄이기 위한 조력자**로 활용했다.
이 방식이 꽤 효율적이었다.

# 1. Google Drive 동기화

앱의 중심이 되는 기능이다.

- Google Drive 연동
- 특정 폴더를 기준으로 로컬 ↔ Drive 동기화
- 변경 사항 감지 후 업로드 / 다운로드

초기에는 단방향만 구현하려 했지만,
나중에 확장을 고려해 구조 자체는 **양방향 동기화**로 설계했다.
현재는 단순한 형태지만, 이후 충돌 해결 로직을 추가하기 쉬운 아키텍처다.

<img src="/assets/images/20260125_01_Google_drive_sync.png" alt="Google_drive_sync" width="60%" style="border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">

›
# 2. 여러 계정 동기화

이 기능은 개인적으로 가장 필요했던 부분이다.
Obsidian을 쓰다 보면 개인 계정과 업무용 계정을 구분해야 하는데,
기존 앱에서는 계정 전환이 번거로웠다.

그래서 **계정별로 독립적인 동기화 설정을 유지**하도록 설계했다.

핵심 포인트는 다음과 같다.

- 계정별 OAuth 토큰 관리
- 계정별 폴더 설정
- 계정별 스케줄 분리

조금 귀찮은 작업이었지만,
이걸 처음부터 분리해두지 않으면 결국 구조를 다시 뜯어야 할 게 뻔했다.

# 3. 동기화 주기 설정

'언제 동기화할 것인가'는 생각보다 중요한 부분이었다.

- 너무 잦으면 배터리가 금방 닳고,
- 너무 길면 동기화의 의미가 없어진다.

그래서 **WorkManager를 기반으로**,
운영체제의 제약을 존중하면서 주기적 백그라운드 동기화를 구현했다.
일정한 주기를 유지하면서도 불필요한 리소스 사용을 최소화하는 게 목표였다.

이 부분은 "지금은 잘 되는데 나중에 안 되는 앱"이 되지 않기 위해
가이드라인을 꽤 꼼꼼히 따랐다.

그래서 15분, 30분, 1시간, 2시간, 6시간, 12시간, 24시간 으로 지정해서 사용했다.

<img src="/assets/images/20260125_04_sync_time.png" alt="sync time" width="60%" style="border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">

# 4. 로고 기능
앱을 만들다 보니 “실제로 동기화가 잘 되고 있는지” 확인할 방법이 필요했다.
그래서 간단하게 로고 표시 기능을 추가했다.

로고는 단순한 장식이 아니라, 동기화 상태를 직관적으로 보여주는 역할을 한다.

오류가 발생하면 빨강색으로 표시하고 내보내기 기능도 만들어서 볼수 있게 만듬.

초기에는 로그캣으로 동작을 확인했는데,
직접 앱을 써보니 시각적인 피드백이 없으면 사용성이 떨어졌다.
그래서 “이왕이면 내가 바로 눈으로 확인할 수 있으면 좋겠다”는 생각으로 로고 기능을 넣었다.
<img src="/assets/images/20260125_05_log.png" alt="log" width="60%" style="border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
---
이제 사용하면된다. 이틀 만에 만든 앱이라 완벽하진 않지만,
내가 직접 쓰기엔 충분했다.
필요한 기능만 빠르게 완성하고,
나머지는 점진적으로 다듬을 계획이다.

# 5. 주요 기능 요약

## 사용 기능

| 기능명 | 주요 내용 | 상세 설명 |
| :--- | :--- | :--- |
| 계정 관리 | Google 계정 인증 및 다중 계정 전환 | OAuth 2.0 기반 안전한 로그인 지원 및 활성 계정의 실시간 전환 기능 제공 |
| 동기화 페어 구성 | 로컬/드라이브 폴더 쌍(Pair) 등록 및 관리 | 로컬 저장소와 구글 드라이브 내 특정 폴더를 매핑하여 개별적인 동기화 규칙 적용 |
| 모니터링 | 실시간 동기화 상태 및 진행률 표시 | 현재 처리 중인 파일명, 전체 진행률(%), 전송 바이트 등을 대시보드에서 실시간 확인 |
| 이력 관리 | 과거 동기화 성공/실패 기록 및 상세 로그 조회 | 모든 동기화 작업의 시작/종료 시간, 처리된 파일 수, 발생한 에러 상세 로그 제공 |

## 설정 기능

| 기능명 | 주요 내용 | 상세 설명 |
| :--- | :--- | :--- |
| 동기화 정책 | 양방향, 업로드 전용, 다운로드 전용 선택 | 사용자의 목적에 따라 파일의 이동 방향(Bidirectional, Local to Drive, Drive to Local)을 결정 |
| 자동화 설정 | 동기화 주기(최소 15분) 및 자동 실행 스케줄링 | WorkManager를 통해 주기적인 백그라운드 동기화를 수행하며 배터리 최적화 고려 |
| 실행 제약 | Wi-Fi 연결 시, 충전 시에만 작동하도록 제한 | 모바일 데이터 소모 방지 및 배터리 보호를 위한 특정 환경 조건 하에서의 실행 제어 |
| 충돌 해결 | 로컬/드라이브 우선순위 및 파일 이름 변경 보관 정책 | 동일 파일 동시 수정 시 덮어쓰기, 건너뛰기, 또는 '_(local)' 접미사를 통한 양쪽 유지 처리 |

소스코드는 GitHub에 공개해 두었다.
관심 있다면 아래 링크에서 확인할 수 있다.

[https://github.com/xmlangel/googledrivesync](https://github.com/xmlangel/googledrivesync)

시행착오 시간이 점점 줄어드는것같다. 점점 AI 친화적인 인간으로 발전해나가는것같다. 

끝.