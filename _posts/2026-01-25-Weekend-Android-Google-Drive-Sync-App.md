---
layout: post
title: "[AI 개발] 주말 프로젝트: 광고 없는 Google Drive 동기화 앱"
date: 2026-01-25 20:00:00 +0900
categories: android-development
tags:
- android
- google-drive
- sync
- ai
- kotlin
---

* 목차
{:toc}

---

주말 동안 간단한 안드로이드 앱 하나를 만들었어.
로고는 Nanobana로 만들었어.

<img src="/assets/images/20260125_drivesync.png" alt="drivesync Logo" width="60%" style="border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">

토요일과 일요일, 이틀 정도 집중해서 만든 앱인데 목적은 아주 단순한 목적에서 시작했지.

**광고 없는 Google Drive 동기화**

# 왜 만들었나

나는 평소 노트 정리 도구로 Obsidian을 사용하고 있고,
노트 저장소는 Google Drive와 동기화해서 관리하고 있었어. 그동안은 **Autosync for Google Drive**를 써왔지.

이 앱은 기능적으로는 꽤 안정적이지만,

- 광고가 점점 잦아지고,
- 커스터마이징 옵션이 제한적이라,
- "조금 더 내가 원하는 대로" 조정하기 어려웠어.

그래서 어느 순간 이런 생각이 들었지.

> "이거, 그냥 내가 하나 만들면 되지 않나?"

# 목표는 '완벽한 앱'이 아니라 '내가 쓸 수 있는 앱'

처음부터 모든 기능을 다 넣을 생각은 없었어. 실제로 필요한 기능을 정리해보니 아래 정도 나오더라고.

1. Google Drive 동기화
2. 여러 계정 동기화
3. 동기화 주기 설정
4. Wi-Fi 환경에서만 동기화
5. 충전 중일 때만 동기화
6. 동기화 완료 알림
7. 충돌 해결 전략

하지만 현실적으로 핵심은 앞의 1, 2, 3번만 되면 된다고 생각했지. 그래서 이번 주말 목표는 정했어.

**"1, 2, 3번 기능만 구현한다."**

하지만 결과적으로 모든 기능을 만들게 되더라고 지시하고 테스트 하고 반복하다보니... 

뚝딱 만들어진... 

# AI를 곁들인 개발 과정

요즘 계속 LLM과 대화 중이야. 두 모델을 병행하면서 역할을 분리해 사용했어.

- **Claude** → 구조 설계, 코드 리팩토링, 로직 검증
- **Gemini** → Android API 힌트, Google Drive 연동 샘플, Coroutine/WorkManager 레퍼런스

AI를 "코드를 대신 작성해주는 도구"로 쓰기보단,
**설계 검증과 시행착오를 줄이기 위한 조력자**로 활용했어.
이 방식이 꽤 효율적인 것 같아.

나중엔 OpenCode를 이용해서 해보는 것도 고민 중이야.

# 1. Google Drive 동기화

앱의 중심이 되는 기능이야.

- Google Drive 연동
- 특정 폴더를 기준으로 로컬 ↔ Drive 동기화
- 변경 사항 감지 후 업로드 / 다운로드

초기에는 단방향만 구현하려 했지만,
나중에 확장을 고려해 구조 자체는 **양방향 동기화**로 설계했어.
현재는 단순한 형태지만, 이후 충돌 해결 로직을 추가하기 쉬운 아키텍처로 가야겠지.

<img src="/assets/images/20260125_01_Google_drive_sync.png" alt="Google_drive_sync" width="60%" style="border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">

# 2. 여러 계정 동기화

이 기능은 개인적으로 가장 필요했던 부분이야.
Obsidian을 쓰다 보면 개인 계정과 업무용 계정을 구분해야 하는데,
기존 앱에서는 계정 전환이 번거로웠어.

그래서 **계정별로 독립적인 동기화 설정을 유지**하도록 설계했어.

핵심 포인트는 다음과 같아.

- 계정별 OAuth 토큰 관리
- 계정별 폴더 설정
- 계정별 스케줄 분리

조금 귀찮은 작업이었지만,
이걸 처음부터 분리해두지 않으면 결국 구조를 다시 뜯어야 할 게 뻔했어.

# 3. 동기화 주기 설정

'언제 동기화할 것인가'는 생각보다 중요한 부분이었어.

- 너무 잦으면 배터리가 금방 닳고,
- 너무 길면 동기화의 의미가 없어지지.

그래서 **WorkManager를 기반으로**,
운영체제의 제약을 존중하면서 주기적 백그라운드 동기화를 구현했어.
일정한 주기를 유지하면서도 불필요한 리소스 사용을 최소화하는 게 목표였어.

이 부분은 "지금은 잘 되는데 나중에 안 되는 앱"이 되지 않기 위해
가이드라인을 꽤 꼼꼼히 따랐어.

그래서 15분, 30분, 1시간, 2시간, 6시간, 12시간, 24시간으로 지정해서 사용했어.

<img src="/assets/images/20260125_04_sync_time.png" alt="sync time" width="60%" style="border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">

# 4. 로고 기능
앱을 만들다 보니 “실제로 동기화가 잘 되고 있는지” 확인할 방법이 필요했어.
그래서 간단하게 로고 표시 기능을 추가했어.

로고는 단순한 장식이 아니라, 동기화 상태를 직관적으로 보여주는 역할을 해.

오류가 발생하면 빨강색으로 표시하고 내보내기 기능도 만들어서 볼 수 있게 만들었어.

초기에는 로그캣으로 동작을 확인했는데,
직접 앱을 써보니 시각적인 피드백이 없으면 사용성이 떨어졌어.
그래서 “이왕이면 내가 바로 눈으로 확인할 수 있으면 좋겠다”는 생각으로 로고 기능을 넣었지.

<img src="/assets/images/20260125_05_log.png" alt="log" width="60%" style="border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">

---

# 5. 주요 기능 요약

## 사용 기능

| 기능명 | 주요 내용 | 상세 설명 |
| :--- | :--- | :--- |
| 계정 관리 | Google 계정 인증 및 다중 계정 전환 | OAuth 2.0 기반 안전한 로그인 지원 및 활성 계정의 실시간 전환 기능 제공 |
| 동기화 페어 구성 | 로컬/드라이브 폴더 쌍(Pair) 등록 및 관리 | 로컬 저장소와 구글 드라이브 내 특정 폴더를 매핑하여 개별적인 동기화 규칙 적용 |
| 모니터링 | 실시간 동기화 상태 및 진행률 표시 | 현재 처리 중인 파일명, 전체 진행률(%), 전송 바이트 등을 대시보드에서 실시간 확인 |
| 이력 관리 | 과거 동기화 성공/실패 기록 및 상세 로그 조회 | 모든 동기화 작업의 시작/종료 시간, 처리된 파일 수, 발생한 에러 상세 로그 제공 |

## 설정 기능

| 기능명 | 주요 내용 | 상세 설명 |
| :--- | :--- | :--- |
| 동기화 정책 | 양방향, 업로드 전용, 다운로드 전용 선택 | 사용자의 목적에 따라 파일의 이동 방향(Bidirectional, Local to Drive, Drive to Local)을 결정 |
| 자동화 설정 | 동기화 주기(최소 15분) 및 자동 실행 스케줄링 | WorkManager를 통해 주기적인 백그라운드 동기화를 수행하며 배터리 최적화 고려 |
| 실행 제약 | Wi-Fi 연결 시, 충전 시에만 작동하도록 제한 | 모바일 데이터 소모 방지 및 배터리 보호를 위한 특정 환경 조건 하에서의 실행 제어 |
| 충돌 해결 | 로컬/드라이브 우선순위 및 파일 이름 변경 보관 정책 | 동일 파일 동시 수정 시 덮어쓰기, 건너뛰기, 또는 '_(local)' 접미사를 통한 양쪽 유지 처리 |

소스코드는 GitHub에 공개해 뒀어.
관심 있다면 아래 링크에서 확인할 수 있어.

[https://github.com/xmlangel/googledrivesync](https://github.com/xmlangel/googledrivesync)

## 테스트와 배포 자동화
명세기 QA인데 오류가 발생하면 좀 민망하잖아.
그래서 기본적인 기능 보증은 만들어놔야겠다고 생각해서. 아주 기본적인 **단위 테스트(Unit Test)**를 먼저 넣었어.
아래 문서들을 참고했으니 읽어보면 좋을듯.

- 명령줄 테스트: [Android Command-Line Testing](https://developer.android.com/tools/testing/command-line)
- 로컬 단위 테스트 빌드: [Local Tests](https://developer.android.com/training/testing/fundamentals)

처음엔 테스트가 깨지고,
몇 가지 기능을 다시 수정하고 테스트 돌리고를 반복했어.
덕분에 실수로 로직이 꼬이는 부분들을 초기에 바로잡을 수 있었어.

한때 Ralph AI를 붙여서 자동 회귀 테스트 시스템으로 확장할까 고민도 했지만,
지금은 토큰 소모가 클 것 같아서.
일단은 “단위 테스트 + 자동 리포팅” 구조로 정리했어.

테스트는 JUnit 형식으로 출력되고,
결과는 내가 만든 테스트 관리 시스템인 Testcraft로 업로드돼.

Github Action

<img src="/assets/images/20260125_06_githubaction.png" alt="github_action" width="60%" style="border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">

짜잔~ TestcaseCraft 자주 써먹어야지..

<img src="/assets/images/20260125_07_testcasecraft_junit_result.png" alt="junit_result" width="60%" style="border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">


이제 사용하면 돼. 이틀 만에 만든 앱이라 완벽하진 않지만,
내가 직접 쓰기엔 충분했어.

필요한 기능만 빠르게 완성하고,나머지는 점진적으로 다듬을 계획이야.

시행착오 시간이 점점 줄어드는 것 같아. 이렇게 AI와 함께 작업하다 보니 점점 AI 친화적인 인간으로 발전해나가는 느낌이야. 

오늘은 여기까지
끝.