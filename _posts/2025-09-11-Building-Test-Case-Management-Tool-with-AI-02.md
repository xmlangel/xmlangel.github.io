---
layout: post
title: "[AI 개발] 2부 제작과정 - QA 엔지니어로 일하며 AI 도구로 테스트 케이스 관리툴 만든 경험담"
date: 2025-09-11 20:42:00 +0900
categories: ai-development
tags:
- ai
- test-management
- testcasecraft
---

* 목차
{:toc}

---

2부를 올려보려고 합니다.

1부에서 LLM 사용기를 다뤘다면, 2부에서는 실제 **TestCaseCraft를 어떻게 설계하고 만들었는지** 그 과정을 기록하려 합니다.  
지난 몇 개월간 진행한 작업들을 기억과 기록을 바탕으로 차근차근 풀어보겠습니다.

- [1부: LLM 사용기]({% post_url 2025-08-10-Building-Test-Case-Management-Tool-with-AI-01 %})
- 2부: 제작과정(현재문서)
- 3부: 미정

그럼 지금까지 어떤 과정을 거쳐 진행해왔는지 하나씩 정리해보겠습니다.  

기억과 작업 중간중간에 남겨둔 기록을 중심으로 작성했습니다.

# 프로젝트 이름 짓기

## TestCaseCraft 라고 명명하다

프로젝트를 시작할 때 가장 먼저 한 일은 **이름을 정하는 것** 이었습니다.

처음엔 단순하게 **TestcaseManagement** 라고 했고,  
다음으로 **I can create testcase** 라는 실용적인 이름도 시도해봤습니다.

하지만 시간이 지나면서 애착이 가는 이름이 필요하다는 생각이 들었습니다.  
자동차를 사랑하는 사람들이 '둥이', '붕붕이'처럼 애칭을 붙이듯이,  
나만의 도구에도 의미 있는 이름을 주고 싶었습니다.

그렇게 해서 탄생한 이름이 **TestCaseCraft** 입니다.  

이 이름에는 단순한 '테스트케이스 관리' 이상의 의미를 담았습니다.  
QA(Quality Assurance)는 단순히 오류를 찾는 일을 넘어,  
품질이라는 결과물을 정성스럽게 만들어가는 **장인(Craftsman)** 의 과정이라고 생각합니다.

그래서 이 프로젝트를 통해, 마치 장인이 자신의 작품을 다듬듯  
끝까지 품질을 책임지는 과정을 표현하고 싶었습니다.

조금은 거창하게 들릴 수도 있지만,  
그만큼 애착을 가지고 만든 툴이기에 그 이름이 자연스럽게 느껴졌습니다.

<table>
  <tr>
    <td><img src="/assets/images/testcasecraft_light.jpg" alt="테스트 케이스 크래프트" width="900" style="border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);"></td>
  </tr>
</table>

# 아키텍처 설계

## 어떤 구조와 어떤것들을 고려해서 만들었는지?
### 전체 시스템 구조

**TestCaseCraft**는 단순한 테스트케이스 관리 도구가 아니라,  
QA가 실제로 테스트를 설계하고 실행하는 **전 과정을 효율적으로 지원하는 것**을 목표로 했습니다.

그래서 처음 구조를 설계할 때부터 **'통합'과 '확장성'**을 중심으로 잡았습니다.

```
TestCaseCraft/
├── 📁 Frontend (React SPA)          # 사용자 인터페이스
├── 📁 Backend (Spring Boot API)     # 비즈니스 로직 및 데이터
├── 📁 RAG Service(FastAPI)          # RAG 서비스
├── 📁 Database (PostgreSQL)         # 데이터 저장소
├── 📁 Build System (Gradle)         # 통합 빌드 시스템
├── 📁 Testing (E2E + TestNG)          # 테스트 프레임워크
└── 📁 Integration (JIRA)            # 외부 시스템 연동
└── 📁 Integration (Gmail)            # 메일 시스템 연동
```
이 구조를 통해 **Spring + FastAPI + React + PostgreSQL** 기반의  
개발과 품질을 동시에 아우르는 **QA 플랫폼**으로 확장할 수 있는 기초가 되는 것들을 마련하려고 했습니다. 

---

### Frontend (React SPA)

사용자는 대부분 웹 환경에서 접근하기 때문에,  
**React 기반의 Single Page Application** 형태로 인터페이스를 구성했습니다.

UX를 단순화하는 데 집중했으며,  
테스트케이스 작성·수정·관리 과정을 **끊김 없이 수행**할 수 있도록 설계했습니다.

상태 관리는 **Redux Toolkit**, 통신은 **REST API** 중심으로 구성해  
프론트엔드와 백엔드 간 결합도를 낮췄습니다.

React 18 + Material-UI 7
├── src/
│ ├── components/ # 재사용 가능한 UI 컴포넌트
│ ├── context/ # React Context (전역 상태)
│ ├── services/ # API 호출 서비스
│ ├── models/ # 데이터 모델
│ └── utils/ # 유틸리티 함수

#### 개발 과정의 변화

처음엔 CRA(Create React App)로 시작했습니다.

```
npx create-react-app testcasecraft
cd testcasecraft
npm start
```
하지만 곧 이것이 **React 공식에서 더 이상 권장하지 않는 구식 방식**임을 알게 됐습니다.  
그래서 **Vite**로 전환했고, 현재는 **Vite 7** 버전 기반으로 운영 중입니다.  

UI 라이브러리는 **MUI 5**에서 시작해 **MUI 7**로 업그레이드했습니다.  
리팩토링 과정에서 호환성 문제로 일부 오류가 발생했지만,  
새로운 디자인 시스템으로 맞춰가는 과정이 참 재미있었습니다.

최신화를 해놔야 나중에 고생을 덜한다는 생각으로 

### Backend (Spring Boot API)

저는 20년 이상 QA 업무를 해온 전문가지, 개발자는 아닙니다.  
그래도 예전에 **Spring**을 조금 다뤄본 경험이 있어서, 이를 기반으로 백엔드를 구성했습니다.

무엇보다 **Java**는 안정성과 유지보수 측면에서 여전히 강점이 있다고 생각했습니다.

요즘은 대부분 **Python**을 많이 사용하지만,  
LLM을 적극적으로 활용할 계획이었기에  
무리하게 새로운 언어를 선택하기보다,  
**제가 익숙한 언어로 안정적인 구조를 만드는 게 낫겠다**는 판단이었습니다.

결국 "나중에 수정이나 유지보수가 가능해야 한다"는 현실적인 이유가 가장 컸습니다.

**Spring Boot 3.4** 기반으로 다음과 같이 구성했습니다.

Spring Boot 3.4
├── controllers/ # REST API 엔드포인트
├── services/ # 비즈니스 로직
├── repositories/ # 데이터 접근 계층
├── models/ # JPA 엔티티
├── security/ # JWT 인증 및 권한 관리
└── config/ # 설정 클래스

비즈니스 로직은 테스트케이스, 프로젝트, 사용자 등 **핵심 Entity들을 책임지는 API**를 중심으로 구성했으며,  
추가적인 기능은 별도의 모듈로 독립시켜 유지보수를 용이하게 했습니다.

Spring Security를 이용해 **JWT 기반 인증**과 **역할 기반 접근 제어**를 구현했습니다.

---

### Database (PostgreSQL + pgvector)

시스템의 뼈대는 결국 **데이터베이스**라고 생각했습니다.  
가장 먼저 구조를 잡은 부분이 DB였습니다.

요즘은 거의 표준처럼 **PostgreSQL**을 많이 사용하고 있으며,  
현재 제가 일하고 있는 회사가 PostgreSQL 관련 제품을 개발하고 있기 때문에  
자연스럽게 선택이 이어졌습니다.

사내 제품군(AgensSQL 등)도 고려했지만,  
Docker Hub에 배포할 계획이 있었기 때문에  
일반 PostgreSQL을 사용하는 쪽으로 방향을 잡았습니다.

버전은 **PostgreSQL 18(최신)** 을 사용 중입니다.  
처음 시작하는 것이었기에 최신 버전으로 가야겠다고 생각했습니다.

PostgreSQL 18 + pgvector
├── users # 사용자 관리
├── organizations # 조직 정보
├── projects # 프로젝트
├── testcases # 테스트 케이스
├── executions # 테스트 실행 결과
└── audit_logs # 감사 로그

그리고 LLM과 RAG 기능을 위해 **pgvector** 확장을 적용했습니다.  
덕분에 문서 임베딩과 벡터 검색 기능을 자연스럽게 통합할 수 있었습니다.

추가로, 서비스 단의 DB와 RAG의 DB를 **별도로 운영**하기로 결정했습니다.  
예상치 못한 사고에 대비하잔 생각을 가지고...

### RAG Service (FastAPI)

LLM 활용이 필요한 부분인데, 문제가 있었습니다.  
요즘 LLM 프로젝트는 대부분 **LangChain** 기반으로 구현되지만,  
**LangChain의 공식 Java 버전은 없었습니다.**

그래서 결국 **백엔드를 두 개로 나누기로 결정**했습니다.

- **Spring Boot**: 전통적인 비즈니스 로직과 API 서버 담당  
- **FastAPI**: RAG 및 LLM 관련 기능 담당  

복잡하긴 하지만, LLM 기능을 포기할 수는 없었습니다.

#### 3-Tier 아키텍처

React Frontend → Spring Boot Backend → FastAPI RAG Service

- **Frontend**: 사용자가 문서를 업로드하거나 검색을 요청하는 UI  
- **Spring Boot Backend**: 프론트엔드 요청을 받아 FastAPI로 전달하며, 비즈니스 로직과 인증 처리  
- **FastAPI RAG Service**: 문서 파싱, 임베딩 생성, 벡터 검색 등 핵심 RAG 기능 수행  

이 구조 덕분에 RAG 서비스를 **독립된 마이크로서비스** 형태로 운영할 수 있고,  
기존 Spring 기반 시스템과 자연스럽게 통합됩니다.


### Build System (Gradle)
전체 프로젝트의 통합 빌드를 지원하기 위해 **Gradle 멀티모듈 구조** 를 사용했습니다.  
각 서비스(Backend, RAG, Testing)를 별도로 빌드하면서도, 한 번에 패키징 가능한 구성을 목표로 했습니다.

### Testing (E2E + TestNG)
자동화된 테스트를 위해 **E2E(End-to-End)** 시나리오와 **TestNG 기반 단위 테스트** 두 가지를 병행했습니다.  
E2E 테스트는 실제 브라우저 기반으로 동작 환경을 검증하고,  
TestNG는 API 및 로직 레벨에서 실패 포인트를 조기에 찾아내도록 설계했습니다.

### Integration (JIRA / Gmail)
테스트 관리 프로세스는 실제 개발 사이클과 함께 움직이기 때문에 JIRA 연동을 필수로 고려했습니다.  
테스트 결과를 이슈에 연결하거나, 테스트케이스에서 바로 티켓을 생성할 수 있도록 했습니다.  
또한 Gmail API를 연동해 테스트 실행 결과나 알림 메일을 자동 전송하도록 구현했습니다.

## 어떤 구조와 어떤 것들을 고려해서 만들었는지?

### 전체 아키텍처
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Frontend      │    │   Backend       │    │   Database      │
│   (React)       │◄──►│  (Spring Boot)  │◄──►│  (H2/PostgreSQL)│
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         │              ┌─────────────────┐              │
         └─────────────►│  Authentication │◄─────────────┘
                        │  (JWT + Refresh)│
                        └─────────────────┘
```

### 계층별 구조

##### 프레젠테이션 계층 (Frontend)
```
React 18 + Material-UI
├── src/
│   ├── components/         # 재사용 가능한 UI 컴포넌트
│   ├── context/           # React Context (전역 상태)
│   ├── services/          # API 호출 서비스
│   ├── models/            # 데이터 모델 및 데모 데이터
│   └── utils/             # 유틸리티 함수
```

#### 비즈니스 로직 계층 (Backend)
```
Spring Boot 3.4
├── controllers/           # REST API 엔드포인트
├── services/             # 비즈니스 로직
├── repositories/         # 데이터 접근 계층
├── models/               # JPA 엔티티
├── security/             # 보안 설정
└── config/               # 설정 클래스
```

#### 데이터 계층 (Database)
```
H2 (개발) / PostgreSQL (운영)
├── 사용자 관리 테이블
├── 조직/프로젝트/그룹 테이블
├── 테스트 케이스 테이블
├── 테스트 실행 결과 테이블
└── 감사 로그 테이블
```

### Backend(Spring + FastAPI)

사실 저는 개발자는 20년 넘개 QA 업무만 하고있는 QA 전문가입니다. 

그래도 예전에 **Spring**을 조금 다뤄본 경험이 있어서, 백엔드는 이쪽으로 진행하기로 했습니다.  
무엇보다 **Java** 는 안정성과 유지보수 측면에서 여전히 강점이 있다고 생각했습니다.

요즘은 대부분 **Python** 을 많이 사용하지만, LLM을 적극적으로 활용하게 될 것을 고려했을 때  
무리하게 새로운 언어를 선택하기보다, **제가 익숙한 언어로 안정적인 구조를 만드는 게 낫겠다** 는 판단이었습니다.  
결국 “나중에 수정이나 유지보수가 가능해야 한다”는 현실적인 이유가 가장 컸습니다.

그런데 문제는 **RAG(Retrieval-Augmented Generation)** 구조였습니다.  
요즘 LLM 관련 프로젝트는 대부분 LangChain 기반으로 구현되는데,  
조사해보니 **LangChain의 공식 Java 버전은 없더군요.**  
(있더라도 내가 모르는 분야라 바로 쓰기엔 한계가 많았습니다.)

결국 백엔드를 두 개로 나누기로 결정했습니다.  
**Spring Boot** 는 전통적인 비즈니스 로직과 API 서버를 담당하고,  
**FastAPI** 는 RAG 및 LLM 관련 기능을 담당하도록 구성한 것이죠.  
조금 복잡하긴 하지만, LLM 기능을 포기할 수는 없었습니다.  


### Backend(Spring + FastAPI)
제가 전문 개발자가 아니다 보니 기존에 스프링은 그래도 조금은 해본경험이 있어서 Spring 으로 했어요 JAVA 가 안정성 면에서 낳다는 생각을 했습니다. 그래서 Spring 3.4 베이스로 가게되었죠.

물론 요즘 대세가 Python 이긴 하지만 LLM 에 많은 의존을 하게될 것이기에 내가 할 수 있는 언어를 해야 한다는 생각을 가지고 진행을 했어요 .

나중에 코드가 작성이 되더라도 수정이 가능한 코드를 해야지 오류 수정 이라던가 유지보수가 용이하게 할수 있을거라는 생각을 가지고 진행을 하게되었죠 

그리고 RAG 요즘은 LLM 에 RAG 많이 붙이고 하고 있는데 Backend 를 JAVA 로 모두 하려고 하니 LangChain 을 이용하려고 검색을 해보니 Lanchain 은 JAVA 가 없더라고요 제가 모르는것 일 수도 있지만 암튼..

두가지 Backend 로 작업을 하기로 결정을 했어요 조금은 복잡하지만 그래도 Lanchain 을 포기할수는 없었어요 ..

### Frontend(React)
그리고 제가 옛날사람이라 **Mustache** 같은 템플릿 엔진으로 프론트 작업을 하곤 했습니다. (개발자 아님 단순히 내가 필요한걸 만들어쓰는 정도)  
하지만 이제는 로직 없는 HTML 템플릿 시스템으로는 한계가 명확하더군요.  
그래서 이번엔 **React**로 새롭게 시작해보기로 했습니다.

물론 React를 깊게 써본 경험은 많지 않았습니다.  
단순한 수정이나 구조 파악 정도였지만, 작은 프로젝트를 통해 익히는 게 가장 빠르다고 생각했습니다.

처음엔 아래처럼 기본 CRA로 시작했습니다.

```
npx create-react-app testcasecraft
cd testcasecraft
npm start
```
그런데 곧 알게 되었죠. 이 방식은 이제 **React 공식에서 추천하지 않는 구식 환경**이라는 걸요.  
그래서 결국 **Vite** 로 다시 세팅을 바꿨습니다. 근래에 바꾼 것이고요 
현재는 **Vite 7** 버전 기반으로 동작하며, 훨씬 가볍고 빠른 환경 에서 사용하고 있습니다.

UI 라이브러리는 **MUI(Material UI)** 5버전에서 시작해,  현재는 **MUI 7** 로 업그레이드한 상태입니다.  
리팩토링 과정에서 컴포넌트 일부가 호환되지 않아 오류가 나기도 했지만,   새로운 디자인 시스템으로 맞추는 과정이 참 재미있었습니다.  


### Database(PostgreSQL + pgvector)

시스템의 뼈대는 결국 **데이터베이스**라고 생각했습니다.   그래서 가장 먼저 구조를 잡은 부분이 DB였습니다.

요즘은 거의 표준처럼 **PostgreSQL** 을 많이 사용하기도 하고,  

현재 제가 일하고 있는 회사가 PostgreSQL 관련 제품을 개발하고 있기 때문에 자연스럽게 선택이 이어졌습니다.

사내 제품군도 고려했지만, Docker Hub에 배포할 계획이 있었기 때문에 일반 PostgreSQL을 사용하는 걸로 방향을 잡았습니다.  버전은 최신 버전인 **PostgreSQL 18** 을 사용 중입니다.

최신이 항상 좋은것은 아니지만 그래도 처음 시작하는것이니 최신으로 가야 겠다고 생각을 했죠

그리고 LLM과 RAG 기능을 위해 **pgvector** 을 함께 적용했습니다.  

덕분에 문서 임베딩과 벡터 검색 기반의 기능을 자연스럽게 통합할 수 있었습니다.  

물론 서비스 단의 DB 와 RAG 의 DB를 하나로 할까도하다가 둘로나워서 작업을 하게되었어요 혹시모를 사고를 대비하기위해서 .

### 외부 연동(Jira + Gmail + Playwright)

QA 엔지니어로서 프로젝트를 하다 보면,  이슈 관리 시스템 하나쯤은 반드시 연동해야 한다는 생각이 들었습니다.  
요즘은 대부분 JIRA를 사용하기에(아닐수도 있지만 저의 경험상 대부분 JIRA 를 써왔기에..), 이번 프로젝트에서도 JIRA 연동을 기본으로 잡았습니다.  
게다가 회사에서도 JIRA를 사용하고 있어서, 자연스럽게 실제 환경에 맞춰 개발할 수 있었습니다.

알림 시스템은 처음엔 **Slack**, **Discord**, **Telegram**도 검토했지만,  
일단은 **Gmail**로 간단히 시작했습니다.  
테스트케이스 작성에 대한 알림이나, 결과 백업본을 이메일로 받아보는 형태로요.  
지금은 백업 기능은 구현 중이지만, 추후 자동화할 계획입니다.

또 하나 고민이었던 부분이 **E2E 테스트 자동화**였습니다.  
LLM 기반 서비스는 테스트를 수동으로 하기엔 너무 복잡했습니다.  

처음에는 **Cypress**로 시작했지만,  
나중에 **Microsoft Playwright**로 완전히 전환했습니다.  
속도가 빠르고, 다양한 브라우저 환경에서 병렬 검증이 가능했기 때문입니다.

현재 JIRA와 연동된 작업 이슈만 400개가 넘습니다.  혼자서 하는 프로젝트지만, 5인 제한 무료 플랜 안에서  
개발과 QA, 기능 구상까지 모두 체계적으로 관리하고 있습니다.

<table>
  <tr>
    <td><img src="/assets/images/Jira_TASK.png" alt="JIRA Task" width="900" style="border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);"></td>
  </tr>
</table>

어찌되었든 그렇게 하나씩 하나씩 구조를 잡고 만들어갔습니다. 

이렇게 **Spring + FastAPI + React + PostgreSQL** 기반으로 설계된 TestCaseCraft는  

단순한 테스트 관리 툴을 넘어서, **개발과 품질을 동시에 아우르는 개인형 QA 플랫폼**으로 확장되고 있습니다.


## 요구사항 정의

그럼 이번에는 **TestCaseCraft**의 초기 요구사항을 간단히 정리해보겠습니다.  

처음부터 모든 기능을 다 만들기보다는,  
“꼭 필요한 최소 기능부터 완성하자”는 방향으로 접근했습니다.  
개발 순서는 **Backend → Frontend → RAG 서비스** 순서로 진행했고,  
우선 테스트케이스의 전체적인 구조를 잡는 데 집중했습니다.

###  초기 요구사항

초기 요구사항은 단순했지만,‘QA 엔지니어가 실제로 사용할 수 있는 도구’라는 실제 현장의 관점을 바탕으로 정의했습니다.  
무엇보다 **테스트 관리의 체계와 효율** 을  가장 중요한 가치로 설정했습니다.

#### 핵심 가치
- **체계적 관리**: 조직 → 프로젝트 → 그룹으로 이어지는 계층 구조를 통해 테스트케이스를 체계적으로 관리할 수 있어야 함  
- **보안 중심**: JWT 기반의 인증과 역할(Role) 기반 접근 제어를 통해 안전한 사용자 구분  
- **테스트 자동화**: Playwright를 활용해 E2E 테스트를 자동으로 수행하고 결과를 기록할 수 있도록 구성  
- **실시간 대시보드**: 테스트 진행 현황과 통계를 한눈에 파악할 수 있게 실시간 시각화

#### 주요 사용자
- **테스트 엔지니어**: 테스트케이스 작성 및 실행, 결과 검증  
- **프로젝트 매니저**: 프로젝트별 테스트 진행 상태 모니터링  
- **조직 관리자**: 여러 프로젝트를 아우르는 품질 지표 확인 및 리소스 관리  
- **개발자**: 테스트 결과를 기반으로 결함 수정 및 품질 개선 작업 수행

---

이런 방식으로, 처음엔 단순하지만 분명한 목표를 가진 요구사항으로부터 출발했습니다.  
추후 RAG 기능이 붙고, 자동화 범위가 확장되면서 점점 복잡해졌지만  
이 초기 정의가 전체 시스템의 방향성을 잡아주는 기준이 되어주었습니다.

----

## 기능 요구사항 정리

초기 요구사항을 바탕으로 실제로 구현해야 할 **기능 요구사항**을 구체화했습니다.  
이 단계에서는 테스트 관리의 기본 흐름을 우선 완성하고, RAG 기능은 이후 단계에서 확장하는 방향으로 설계했습니다.

---

### 1. 테스트 케이스 관리

테스트케이스는 QA 업무의 핵심이기 때문에,  
**트리 구조로 한눈에 관리할 수 있는 인터페이스** 를 가장 먼저 고려했습니다.  

- 트리 형태의 폴더 구조를 통한 테스트 케이스 계층적 관리  
- 테스트 케이스의 생성, 수정, 삭제  
- 상세 정보 관리: 테스트 이름, 설명, 테스트 단계, 기대 결과 등  

이 기능을 통해 프로젝트마다 수백, 수천 개 단위의 테스트케이스를  
효율적으로 찾아보고 관리할 수 있도록 했습니다.

---

### 2. 테스트 플랜 관리

테스트케이스가 준비되면, 그다음은 실행 계획을 세워야 합니다.  
그래서 **테스트 플랜 관리 기능** 을 별도로 분리했습니다.

- 테스트 플랜 생성, 수정, 삭제  
- 개별 플랜에 테스트케이스를 연결  
- 실행 단위별 관리 및 통계 기능 연동  

플랜 단위로 테스트를 묶어 관리함으로써  
“프로젝트별 QA 수행 내역”을 직관적으로 파악할 수 있도록 설계했습니다.

---

### 3. 테스트 실행 관리

테스트 실행은 실제 품질 검증 프로세스의 핵심입니다.  
이 단계에서는 테스트케이스의 실행 상태와 결과를 관리할 수 있도록 했습니다.

- 테스트 실행 생성, 수정, 삭제  
- 개별 케이스의 **Pass/Fail 결과 기록**  
- 결과 입력 후 자동으로 다음 케이스로 이동  

테스트 엔지니어가 일일이 페이지를 전환하지 않아도  
빠르게 테스트를 이어나갈 수 있도록 **UX 효율성**을 중점에 두었습니다.

---

## RAG (LangChain 기반 서비스)

RAG 부분은 프로젝트 후반부에 추가된 기능이지만,  
LLM을 실질적으로 활용하기 위해 빼놓을 수 없는 영역이었습니다.  
전체 RAG 서비스는 **FastAPI 기반 문서 처리 및 벡터 검색 서비스**로 구성했습니다.

### 주요 기능
- **문서 업로드 및 저장**: MinIO를 이용한 S3 호환 객체 스토리지 지원  
- **문서 파싱**: 4가지 파서 (Upstage API, PyMuPDF4LLM, PyMuPDF, PyPDF2)  
- **텍스트 임베딩**: Sentence Transformers 기반 768차원 벡터 생성  
- **벡터 검색**: PostgreSQL + pgvector를 활용한 유사도 기반 검색  
- **대화 관리**: 검색 문맥 저장 및 대화형 QA 인터페이스 지원  

처음에는 파일을 단순히 로컬 파일시스템에 저장했지만,  
나중에 S3나 클라우드 환경으로 확장할 가능성을 고려해 **MinIO**로 전환했습니다.  

초기에는 **Upstage API**를 이용해 파싱 테스트를 했지만,  
지금은 약 95% 이상의 케이스를 **PyMuPDF4LLM** 기반으로 처리하고 있습니다.  
이 모듈은 속도와 파싱 품질 면에서 가장 안정적이었습니다. 아직까지는요 향후 더 낳은것이 있다면 고려해볼예정이에요 .

## RAG 아키텍처 구조

RAG 시스템은 단순히 API를 직접 호출하는 형태가 아니라,  
**3-Tier 아키텍처**로 구성했습니다.

React Frontend → Spring Boot Backend → FastAPI RAG Service

- **Frontend**: 사용자가 문서를 업로드하거나 검색을 요청하는 UI 영역  
- **Spring Boot Backend**: 프론트엔드 요청을 받아 FastAPI 서비스로 전달하며, 비즈니스 로직과 인증을 처리  
- **FastAPI RAG Service**: 문서 파싱, 임베딩 생성, 벡터 검색 등 핵심적인 RAG 기능 수행  

이런 구조는 RAG 서비스를 하나의 **독립 마이크로서비스**처럼 운영할 수 있게 하도록했고.  
또 기존 Spring 기반 시스템과 자연스럽게 연동이 가능해,  
서로 다른 언어로 작성된 서비스 간에도 유연한 통신이 이루어질수 있게 했어요.

임베딩과 검색은 대부분 **FastAPI RAG Service**에서 처리되며,  
Spring 측에서는 그 결과를 받아 프론트엔드에서 활용하기 좋은 형태로 만들려고 노력했습니다. 


# RAG (LangChain 기반)

RAG 서비스는 **FastAPI 기반 문서 처리 및 벡터 검색 서비스**로 설계 했어요.  
LangChain 프레임워크를 중심으로, 문서 파싱부터 임베딩, 검색, 대화 컨텍스트 관리까지 일련의 흐름을 구성 했죠.

### 주요 기능
- **문서 업로드 및 저장**: MinIO를 활용한 S3 호환 객체 스토리지  
- **문서 파싱**: Upstage API, PyMuPDF4LLM, PyMuPDF, PyPDF2 등 4가지 파서 지원  
- **텍스트 임베딩**: Sentence Transformers 기반 768차원 벡터 생성  
- **벡터 검색**: PostgreSQL + pgvector를 이용한 유사도 기반 검색  
- **대화 관리**: 검색 기반의 대화 컨텍스트 관리  


### 기술 스택
```
FastAPI                    - REST API 프레임워크
PostgreSQL + pgvector      - 벡터 데이터베이스
MinIO (7.2.0)              - S3 호환 객체 스토리지
Sentence Transformers      - 텍스트 임베딩 (768차원)
LangChain                  - 텍스트 청킹
```
초기에는 단순히 파일시스템에 문서를 저장했지만,  나중에 AWS S3와 같은 외부 스토리지를 손쉽게 확장할 수 있도록 **MinIO**를 도입 했어요. 처음엔 **Upstage API** 기반으로 파싱을 시도했지만 비용적인 측면때문에   
현재는 약 **95% 이상을 PyMuPDF4LLM**으로 처리하고 있습니다.  
그런데 해보니 속도나 텍스트 변환 품질에서 안정적 이었던것같아요 


## RAG 임베딩 프로세스

문서 업로드부터 벡터 임베딩 저장까지의 흐름은 다음과 같이 구성했어요 

```
React Frontend -> Spring Boot Backend -> FastAPI RAG Service
```

### 임베딩 처리 순서

**1단계: 문서 업로드 (Frontend → Backend)**  
- 사용자가 RAG 페이지에서 문서를 업로드  
- Spring Backend는 해당 요청을 FastAPI로 전달

**2단계: 문서 저장 및 처리 요청 (Backend → FastAPI)**  
- FastAPI 서비스가 문서를 MinIO(S3 호환 스토리지)에 저장  
- 초기에는 로컬 저장을 고려했지만 확장성을 위해 MinIO를 기본 구조로 설정  

**3단계: 문서 파싱 및 청킹 (FastAPI)**  
- 문서를 텍스트로 변환한 후, 의미 단위로 적절히 나눈 **청크(chunk)** 단위로 처리  
- 각 청크는 원본 문서의 식별 정보와 함께 PostgreSQL에 저장  

**4단계: 임베딩 생성 (FastAPI → Sentence Transformer)**  
- 각 청크를 벡터 임베딩으로 변환하여 `pgvector` 컬럼에 저장  
- 이를 통해 향후 유사도 기반 검색이나 QA 응답 강화 시 활용 가능  

---


### 구성 기술 요약

- **FastAPI**: RAG의 핵심 API 및 워크플로우 관리  
- **OpenAI (text-embedding-ada-002)**: 텍스트의 임베딩 벡터 생성  
- **PostgreSQL + pgvector**: 문서 청크 및 임베딩 데이터 영속화  
- **MinIO**: 업로드된 원본 문서 저장 (S3 호환 인터페이스)  

---
이 구조를 통해 TestCaseCraft의 RAG 시스템은  
문서 기반 지식검색뿐 아니라 향후 자동 **테스트케이스 생성**이나  
**QA 문서 요약** 같은 기능으로도 손쉽게 확장할 수 있는 기반을 갖추게 되었습니다.

그렇게 해서 나온 결과물의 구조는 아래와 같았어요.

<table>
  <tr>
    <td><img src="/assets/images/RAG_Structure.png" alt="RAG Structure" width="900" style="border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);"></td>
  </tr>
</table>

현재 대부분 Ollama 에 gpt-oss:120b 모델을 가지고 임베징진행해서 작업해나가고 있습니다.

그렇게 상태가 나쁘지는 않아요.. 

정리하고나니 상당히 복잡한 구조로 가 나왔네요 





